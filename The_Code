
import time

def SelectionSort(A):
    for i in range(len(A)):
        min_idx = i
        for j in range(i + 1, len(A)):
            if A[min_idx] > A[j]:
                min_idx = j
        A[i], A[min_idx] = A[min_idx], A[i]

def Bubble_Sort(A):
    for i in range(n):
        for j in range(0, n - i - 1):
            if A[j] > A[j + 1]:
                A[j], A[j + 1] = A[j + 1], A[j]

def InsertionSort(A):
    for i in range(1, len(A)):
        a = A[i]
        j = i - 1
        while j >= 0 and a < A[j]:
            A[j + 1] = A[j]
            j -= 1
        A[j + 1] = a

def MergeSort(A):
    if len(A) > 1:
        m = len(A) // 2
        L = A[:m]
        R = A[m:]
        MergeSort(L)
        MergeSort(R)
        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                A[k] = L[i]
                i += 1
            else:
                A[k] = R[j]
                j += 1
            k += 1
        while i < len(L):
            A[k] = L[i]
            i += 1
            k += 1
        while j < len(R):
            A[k] = R[j]
            j += 1
            k += 1

def Partition(s, e, A):
    pivot = s
    piv = A[pivot]
    while s < e:
        while s < len(A) and A[s] <= piv:
            s += 1
        while A[e] > piv:
            e -= 1
        if (s < e):
            A[s], A[e] = A[e], A[s]
    A[e], A[pivot] = A[pivot], A[e]
    return e

def QuickSort(s, e, A):
    if (s < e):
        p = Partition(s, e, A)
        QuickSort(s, p - 1, A)
        QuickSort(p + 1, e, A)

def Heapify(A, n, i):
    L = i
    l = 2 * i + 1
    r = 2 * i + 2
    if l < n and A[L] < A[l]:
        L = l
    if r < n and A[L] < A[r]:
        L = r
    if L != i:
        A[i], A[L] = A[L], A[i]
        Heapify(A, n, L)

def HeapSort(A):
    n = len(A)
    for i in range(n // 2 - 1, -1, -1):
        Heapify(A, n, i)
    for i in range(n - 1, 0, -1):
        A[i], A[0] = A[0], A[i]
        Heapify(A, i, 0)

def CountingSort(A):
    size = len(A)
    output = [0] * size
    count = [0] * 10000
    for i in range(0, size):
        count[A[i]] += 1
    for i in range(1, 10000):
        count[i] += count[i - 1]
    i = size - 1
    while i >= 0:
        output[count[A[i]] - 1] = A[i]
        count[A[i]] -= 1
        i -= 1
    for i in range(0, size):
        A[i] = output[i]

def CountSort(A, ex):
    n = len(A)
    final = [0] * (n)
    count = [0] * (10)
    for i in range(0, n):
        ind = A[i] // ex
        count[ind % 10] += 1
    for i in range(1, 10):
        count[i] += count[i - 1]
    i = n - 1
    while i >= 0:
        ind = A[i] // ex
        final[count[ind % 10] - 1] = A[i]
        count[ind % 10] -= 1
        i -= 1
    i = 0
    for i in range(0, len(A)):
        A[i] = final[i]

def RadixSort(A):
    max1 = max(A)
    ex = 1
    while max1 / ex > 1:
        CountSort(A, ex)
        ex *= 10

limit = 32
def CalcLim(n):
    r = 0
    while n >= limit:
        r |= n & 1
        n >>= 1
    return n + r

def InsertionSort_LR(A, left, right):
    for i in range(left + 1, right + 1):
        j = i
        while j > left and A[j] < A[j - 1]:
            A[j], A[j - 1] = A[j - 1], A[j]
            j -= 1

def Merge(A, l, m, r):
    len1, len2 = m - l + 1, r - m
    left, right = [], []
    for i in range(0, len1):
        left.append(A[l + i])
    for i in range(0, len2):
        right.append(A[m + 1 + i])
    i, j, k = 0, 0, l
    while i < len1 and j < len2:
        if left[i] <= right[j]:
            A[k] = left[i]
            i += 1
        else:
            A[k] = right[j]
            j += 1
        k += 1
    while i < len1:
        A[k] = left[i]
        k += 1
        i += 1
    while j < len2:
        A[k] = right[j]
        k += 1
        j += 1

def TimSort(A):
    n = len(A)
    m = CalcLim(n)
    for start in range(0, n, m):
        end = min(start + m - 1, n - 1)
        InsertionSort_LR(A, start, end)
    size = m
    while size < n:
        for left in range(0, n, 2 * size):
            mid = min(n - 1, left + size - 1)
            right = min((left + 2 * size - 1), (n - 1))
            if mid < right:
                Merge(A, left, mid, right)

        size = 2 * size



n=100000
Array = [] #The array to be sorted
with open( "numbers_in.txt", "r") as f:
    for i in range(1,n):
        numbers = f.readline()
        separated_numbers = numbers.split()
        for i in separated_numbers:
            Array.append(int(i))

start = time.process_time()
tic=time.time()

#Call whatever function to sort the array
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#SelectionSort(Array)
#Bubble_Sort(Array)
#InsertionSort(Array)
#MergeSort(Array)
#QuickSort(0,9999,Array)
#HeapSort(Array)
#CountingSort(Array)
#RadixSort(Array)
#TimSort(Array)


end = time.process_time()
tac=time.time()

with open ("output.txt", "w") as f:
    f.write(" \n")
    f.write("Our sorted list is:\n")
    for i in range(len(Array)):
        f.write("%d" % Array[i])
        f.write(" ")

with open ("output.txt", "a") as f:
    f.write(" \n")
    f.write(" \n")
    a = end - start
    f.write("The time taken by process_time() function is ")
    f.write(str(a))
    f.write(" \n")
    b=tac-tic
    f.write("The time taken by time() is ")
    f.write(str(b))


